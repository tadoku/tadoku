// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: registrations.sql

package postgres

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const findContestRegistrationForUser = `-- name: FindContestRegistrationForUser :one
select
  contest_registrations.id,
  contest_registrations.contest_id,
  contest_registrations.user_id,
  contest_registrations.language_codes,
  users.display_name as user_display_name,
  contests.activity_type_id_allow_list,
  contests.registration_end,
  contests.contest_start,
  contests.contest_end,
  contests.private,
  contests.official,
  contests.title,
  contests.description
from contest_registrations
inner join contests
  on contests.id = contest_registrations.contest_id
inner join users
  on users.id = contest_registrations.user_id
where
  user_id = $1
  and contest_id = $2
  and contest_registrations.deleted_at is null
`

type FindContestRegistrationForUserParams struct {
	UserID    uuid.UUID
	ContestID uuid.UUID
}

type FindContestRegistrationForUserRow struct {
	ID                      uuid.UUID
	ContestID               uuid.UUID
	UserID                  uuid.UUID
	LanguageCodes           []string
	UserDisplayName         string
	ActivityTypeIDAllowList []int32
	RegistrationEnd         time.Time
	ContestStart            time.Time
	ContestEnd              time.Time
	Private                 bool
	Official                bool
	Title                   string
	Description             sql.NullString
}

func (q *Queries) FindContestRegistrationForUser(ctx context.Context, arg FindContestRegistrationForUserParams) (FindContestRegistrationForUserRow, error) {
	row := q.db.QueryRowContext(ctx, findContestRegistrationForUser, arg.UserID, arg.ContestID)
	var i FindContestRegistrationForUserRow
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.UserID,
		pq.Array(&i.LanguageCodes),
		&i.UserDisplayName,
		pq.Array(&i.ActivityTypeIDAllowList),
		&i.RegistrationEnd,
		&i.ContestStart,
		&i.ContestEnd,
		&i.Private,
		&i.Official,
		&i.Title,
		&i.Description,
	)
	return i, err
}

const findOngoingContestRegistrationForUser = `-- name: FindOngoingContestRegistrationForUser :many
select
  contest_registrations.id,
  contest_registrations.contest_id,
  contest_registrations.user_id,
  contest_registrations.language_codes,
  users.display_name as user_display_name,
  contests.activity_type_id_allow_list,
  contests.registration_end,
  contests.contest_start,
  contests.contest_end,
  contests.private,
  contests.official,
  contests.title,
  contests.description,
  contests.owner_user_id,
  owner_users.display_name as owner_user_display_name
from contest_registrations
inner join contests
  on contests.id = contest_registrations.contest_id
inner join users
  on users.id = contest_registrations.user_id
inner join users as owner_users
  on owner_users.id = contests.owner_user_id
where
  user_id = $1
  and contests.contest_start <= $2::timestamp
  and (contests.contest_end + '1 day'::interval) > $2::timestamp
  and contest_registrations.deleted_at is null
`

type FindOngoingContestRegistrationForUserParams struct {
	UserID uuid.UUID
	Now    time.Time
}

type FindOngoingContestRegistrationForUserRow struct {
	ID                      uuid.UUID
	ContestID               uuid.UUID
	UserID                  uuid.UUID
	LanguageCodes           []string
	UserDisplayName         string
	ActivityTypeIDAllowList []int32
	RegistrationEnd         time.Time
	ContestStart            time.Time
	ContestEnd              time.Time
	Private                 bool
	Official                bool
	Title                   string
	Description             sql.NullString
	OwnerUserID             uuid.UUID
	OwnerUserDisplayName    string
}

func (q *Queries) FindOngoingContestRegistrationForUser(ctx context.Context, arg FindOngoingContestRegistrationForUserParams) ([]FindOngoingContestRegistrationForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, findOngoingContestRegistrationForUser, arg.UserID, arg.Now)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindOngoingContestRegistrationForUserRow
	for rows.Next() {
		var i FindOngoingContestRegistrationForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.ContestID,
			&i.UserID,
			pq.Array(&i.LanguageCodes),
			&i.UserDisplayName,
			pq.Array(&i.ActivityTypeIDAllowList),
			&i.RegistrationEnd,
			&i.ContestStart,
			&i.ContestEnd,
			&i.Private,
			&i.Official,
			&i.Title,
			&i.Description,
			&i.OwnerUserID,
			&i.OwnerUserDisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findYearlyContestRegistrationForUser = `-- name: FindYearlyContestRegistrationForUser :many
select
  contest_registrations.id,
  contest_registrations.contest_id,
  contest_registrations.user_id,
  contest_registrations.language_codes,
  users.display_name as user_display_name,
  contests.activity_type_id_allow_list,
  contests.registration_end,
  contests.contest_start,
  contests.contest_end,
  contests.private,
  contests.official,
  contests.title,
  contests.description
from contest_registrations
inner join contests
  on contests.id = contest_registrations.contest_id
inner join users
  on users.id = contest_registrations.user_id
where
  user_id = $1
  and (contests.private != true or $2::boolean)
  and extract(year from contests.contest_start) = $3::integer
  and contest_registrations.deleted_at is null
`

type FindYearlyContestRegistrationForUserParams struct {
	UserID         uuid.UUID
	IncludePrivate bool
	Year           int32
}

type FindYearlyContestRegistrationForUserRow struct {
	ID                      uuid.UUID
	ContestID               uuid.UUID
	UserID                  uuid.UUID
	LanguageCodes           []string
	UserDisplayName         string
	ActivityTypeIDAllowList []int32
	RegistrationEnd         time.Time
	ContestStart            time.Time
	ContestEnd              time.Time
	Private                 bool
	Official                bool
	Title                   string
	Description             sql.NullString
}

func (q *Queries) FindYearlyContestRegistrationForUser(ctx context.Context, arg FindYearlyContestRegistrationForUserParams) ([]FindYearlyContestRegistrationForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, findYearlyContestRegistrationForUser, arg.UserID, arg.IncludePrivate, arg.Year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindYearlyContestRegistrationForUserRow
	for rows.Next() {
		var i FindYearlyContestRegistrationForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.ContestID,
			&i.UserID,
			pq.Array(&i.LanguageCodes),
			&i.UserDisplayName,
			pq.Array(&i.ActivityTypeIDAllowList),
			&i.RegistrationEnd,
			&i.ContestStart,
			&i.ContestEnd,
			&i.Private,
			&i.Official,
			&i.Title,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertContestRegistration = `-- name: UpsertContestRegistration :one
insert into contest_registrations (
  id,
  contest_id,
  user_id,
  language_codes
) values (
  $1,
  $2,
  $3,
  $4
) on conflict (id) do
update set
  language_codes = $4,
  updated_at = now()
returning id
`

type UpsertContestRegistrationParams struct {
	ID            uuid.UUID
	ContestID     uuid.UUID
	UserID        uuid.UUID
	LanguageCodes []string
}

func (q *Queries) UpsertContestRegistration(ctx context.Context, arg UpsertContestRegistrationParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, upsertContestRegistration,
		arg.ID,
		arg.ContestID,
		arg.UserID,
		pq.Array(arg.LanguageCodes),
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
